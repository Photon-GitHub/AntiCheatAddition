package de.photon.anticheataddition.modules.sentinel.exploits;

import de.photon.anticheataddition.ServerVersion;
import de.photon.anticheataddition.modules.ModuleLoader;
import net.md_5.bungee.api.chat.BaseComponent;
import net.md_5.bungee.api.chat.ClickEvent;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerEditBookEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BookMeta;
import org.jetbrains.annotations.NotNull;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;

public final class BookPageSentinel extends IllegalItemSentinel
{
    public static final BookPageSentinel INSTANCE = new BookPageSentinel();

    private final int maxPageCount = loadInt(".max_page_count", 100);
    private final boolean disallowOpenFile = loadBoolean(".disallow_open_file", true);
    private final boolean disallowCustomColors = loadBoolean(".disallow_custom_colors", true);
    private final List<String> disallowedCommands = loadStringList(".disallowed_commands").stream().map(String::toLowerCase).toList();

    private BookPageSentinel()
    {
        super("Exploits.BookPage");
    }

    @EventHandler(ignoreCancelled = true)
    public void onPlayerEditBook(PlayerEditBookEvent event)
    {
        if (isIllegalBookMeta(event.getNewBookMeta())) {
            event.setCancelled(true);
            detection(event.getPlayer());
        }
    }

    @Override
    protected boolean isIllegalStack(@NotNull ItemStack stack)
    {
        return switch (stack.getType()) {
            // If the stack is a book with custom data, check the book meta.
            case WRITTEN_BOOK, WRITABLE_BOOK -> isIllegalBookMeta((BookMeta) stack.getItemMeta());
            default -> false;
        };
    }

    private boolean isIllegalBookMeta(BookMeta meta)
    {
        if (meta == null) return false;
        if (meta.getPageCount() > maxPageCount) return true;

        // Try-catch for custom chat color handling that on access of the pages throws an error.
        try {
            final var clickEvents = meta.spigot().getPages().stream()
                                        .flatMap(Arrays::stream)
                                        .map(BaseComponent::getClickEvent)
                                        .filter(Objects::nonNull)
                                        .toList();

            if (disallowOpenFile &&
                // Any ClickEvent action opens a file.
                clickEvents.stream().map(ClickEvent::getAction).anyMatch(action -> action == ClickEvent.Action.OPEN_FILE)) return true;

            // Now, we only need to check for disallowed commands. If there are none, the book is allowed.
            if (disallowedCommands.isEmpty()) return false;

            return clickEvents.stream()
                              .filter(event -> event.getAction() == ClickEvent.Action.RUN_COMMAND)
                              // Get the command.
                              .map(ClickEvent::getValue)
                              // Make sure we test all cases and formatting.
                              .map(String::strip)
                              .map(String::toLowerCase)
                              // Remove leading slashes.
                              .map(command -> command.charAt(0) == '/' ? command.substring(1) : command)
                              // If any command in the book starts with a disallowedCommand, the book is evil.
                              .anyMatch(command -> disallowedCommands.stream().anyMatch(command::startsWith));

        } catch (IllegalArgumentException exception) {
            if (exception.getMessage().contains("ChatColor")) return disallowCustomColors;
            else throw exception;
        }
    }

    @Override
    protected ModuleLoader createModuleLoader()
    {
        return ModuleLoader.builder(this)
                           // Changes to metas and materials.
                           .setAllowedServerVersions(ServerVersion.MC115.getSupVersionsFrom())
                           .build();
    }
}
